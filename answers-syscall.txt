1. Looking at the backtrace output, which function called syscall?

(gdb) bt
#0  syscall () at kernel/syscall.c:137
#1  0x0000000080001d70 in usertrap () at kernel/trap.c:67
#2  0x0505050505050505 in ?? ()
(gdb) p /x $sstatus


2. What is the value of p->trapframe->a7 and what does that value represent? (Hint: look user/initcode.S, the first user program xv6 starts.)

(gdb) p p->trapframe->a7
$5 = 7

7 = SYS_exec


3. What was the previous mode that the CPU was in?

(gdb) p /x $sstatus
$6 = 0x22

0x22 = SSTATUS_SPIE | SSTATUS_SIE


4. Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable num?


│   0x8000204e <syscall+18> mv      s1,a0                                                 │
│B+>0x80002050 <syscall+20> lw      a3,0(zero) # 0x0                                      │
│   0x80002054 <syscall+24> addiw   a4,a3,-1     


(gdb) b *0x0000000080002050
Breakpoint 1 at 0x80002050: file kernel/syscall.c, line 138.
(gdb) layout asm
(gdb) c
Continuing.

Thread 1 hit Breakpoint 1, syscall () at kernel/syscall.c:138
(gdb) 

num is a3

5. Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above? (See description of scause in RISC-V privileged instructions)

0(zero) # 0x0  can not mapping to physical address



6. What is the name of the binary that was running when the kernel paniced? What is its process id (pid)?

(gdb) p p->name
$3 = "initcode\000\000\000\000\000\000\000"
(gdb) p p->pid 
$4 = 1